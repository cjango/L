// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import types2 "github.com/33cn/chain33/types"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GameStartReq struct {
	Round int64 `protobuf:"varint,1,opt,name=round" json:"round,omitempty"`
}

func (m *GameStartReq) Reset()                    { *m = GameStartReq{} }
func (m *GameStartReq) String() string            { return proto.CompactTextString(m) }
func (*GameStartReq) ProtoMessage()               {}
func (*GameStartReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *GameStartReq) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type GameDrawReq struct {
	Round int64 `protobuf:"varint,1,opt,name=round" json:"round,omitempty"`
}

func (m *GameDrawReq) Reset()                    { *m = GameDrawReq{} }
func (m *GameDrawReq) String() string            { return proto.CompactTextString(m) }
func (*GameDrawReq) ProtoMessage()               {}
func (*GameDrawReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *GameDrawReq) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type GameBuyKeysReq struct {
	Num int64 `protobuf:"varint,1,opt,name=num" json:"num,omitempty"`
}

func (m *GameBuyKeysReq) Reset()                    { *m = GameBuyKeysReq{} }
func (m *GameBuyKeysReq) String() string            { return proto.CompactTextString(m) }
func (*GameBuyKeysReq) ProtoMessage()               {}
func (*GameBuyKeysReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *GameBuyKeysReq) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

type KeyInfoQueryReq struct {
	Addr  string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	Round int64  `protobuf:"varint,2,opt,name=round" json:"round,omitempty"`
}

func (m *KeyInfoQueryReq) Reset()                    { *m = KeyInfoQueryReq{} }
func (m *KeyInfoQueryReq) String() string            { return proto.CompactTextString(m) }
func (*KeyInfoQueryReq) ProtoMessage()               {}
func (*KeyInfoQueryReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *KeyInfoQueryReq) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *KeyInfoQueryReq) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

type RoundInfoQueryReq struct {
	Round int64 `protobuf:"varint,1,opt,name=round" json:"round,omitempty"`
}

func (m *RoundInfoQueryReq) Reset()                    { *m = RoundInfoQueryReq{} }
func (m *RoundInfoQueryReq) String() string            { return proto.CompactTextString(m) }
func (*RoundInfoQueryReq) ProtoMessage()               {}
func (*RoundInfoQueryReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *RoundInfoQueryReq) GetRound() int64 {
	if m != nil {
		return m.Round
	}
	return 0
}

func init() {
	proto.RegisterType((*GameStartReq)(nil), "types.GameStartReq")
	proto.RegisterType((*GameDrawReq)(nil), "types.GameDrawReq")
	proto.RegisterType((*GameBuyKeysReq)(nil), "types.GameBuyKeysReq")
	proto.RegisterType((*KeyInfoQueryReq)(nil), "types.KeyInfoQueryReq")
	proto.RegisterType((*RoundInfoQueryReq)(nil), "types.RoundInfoQueryReq")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for F3D service

type F3DClient interface {
	Start(ctx context.Context, in *F3DStart, opts ...grpc.CallOption) (*types2.UnsignTx, error)
	LuckyDraw(ctx context.Context, in *F3DLuckyDraw, opts ...grpc.CallOption) (*types2.UnsignTx, error)
	BuyKeys(ctx context.Context, in *F3DBuyKey, opts ...grpc.CallOption) (*types2.UnsignTx, error)
}

type f3DClient struct {
	cc *grpc.ClientConn
}

func NewF3DClient(cc *grpc.ClientConn) F3DClient {
	return &f3DClient{cc}
}

func (c *f3DClient) Start(ctx context.Context, in *F3DStart, opts ...grpc.CallOption) (*types2.UnsignTx, error) {
	out := new(types2.UnsignTx)
	err := grpc.Invoke(ctx, "/types.f3d/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f3DClient) LuckyDraw(ctx context.Context, in *F3DLuckyDraw, opts ...grpc.CallOption) (*types2.UnsignTx, error) {
	out := new(types2.UnsignTx)
	err := grpc.Invoke(ctx, "/types.f3d/LuckyDraw", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *f3DClient) BuyKeys(ctx context.Context, in *F3DBuyKey, opts ...grpc.CallOption) (*types2.UnsignTx, error) {
	out := new(types2.UnsignTx)
	err := grpc.Invoke(ctx, "/types.f3d/BuyKeys", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for F3D service

type F3DServer interface {
	Start(context.Context, *F3DStart) (*types2.UnsignTx, error)
	LuckyDraw(context.Context, *F3DLuckyDraw) (*types2.UnsignTx, error)
	BuyKeys(context.Context, *F3DBuyKey) (*types2.UnsignTx, error)
}

func RegisterF3DServer(s *grpc.Server, srv F3DServer) {
	s.RegisterService(&_F3D_serviceDesc, srv)
}

func _F3D_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(F3DStart)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F3DServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.f3d/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F3DServer).Start(ctx, req.(*F3DStart))
	}
	return interceptor(ctx, in, info, handler)
}

func _F3D_LuckyDraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(F3DLuckyDraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F3DServer).LuckyDraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.f3d/LuckyDraw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F3DServer).LuckyDraw(ctx, req.(*F3DLuckyDraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _F3D_BuyKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(F3DBuyKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(F3DServer).BuyKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.f3d/BuyKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(F3DServer).BuyKeys(ctx, req.(*F3DBuyKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _F3D_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.f3d",
	HandlerType: (*F3DServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _F3D_Start_Handler,
		},
		{
			MethodName: "LuckyDraw",
			Handler:    _F3D_LuckyDraw_Handler,
		},
		{
			MethodName: "BuyKeys",
			Handler:    _F3D_BuyKeys_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 254 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x90, 0x41, 0x4b, 0xc4, 0x30,
	0x10, 0x85, 0xad, 0xb5, 0x4a, 0x47, 0x71, 0x77, 0x47, 0x0f, 0xd2, 0x93, 0x44, 0x0f, 0x8a, 0xd0,
	0x83, 0x39, 0x7a, 0x13, 0x51, 0x64, 0xbd, 0x58, 0xf5, 0x07, 0xc4, 0x26, 0x95, 0x45, 0x36, 0xa9,
	0xd3, 0x04, 0xcd, 0x2f, 0xf1, 0xef, 0x4a, 0xd2, 0xd5, 0x2a, 0xd4, 0xdb, 0xcb, 0xcb, 0xf7, 0x98,
	0x79, 0x03, 0x39, 0xb5, 0x75, 0xd9, 0x92, 0xb1, 0x06, 0x33, 0xeb, 0x5b, 0xd5, 0x15, 0x33, 0x4b,
	0x42, 0x77, 0xa2, 0xb6, 0x0b, 0xa3, 0xfb, 0x9f, 0x22, 0x6f, 0xb8, 0xec, 0x25, 0x3b, 0x86, 0x9d,
	0x1b, 0xb1, 0x54, 0x0f, 0x56, 0x90, 0xad, 0xd4, 0x1b, 0xee, 0x43, 0x46, 0xc6, 0x69, 0x79, 0x90,
	0x1c, 0x26, 0x27, 0x69, 0xd5, 0x3f, 0xd8, 0x11, 0x6c, 0x07, 0xea, 0x8a, 0xc4, 0xfb, 0xff, 0x10,
	0x83, 0xdd, 0x00, 0x5d, 0x3a, 0x3f, 0x57, 0xbe, 0x0b, 0xdc, 0x14, 0x52, 0xed, 0x96, 0x2b, 0x2a,
	0x48, 0x76, 0x01, 0x93, 0xb9, 0xf2, 0xb7, 0xba, 0x31, 0xf7, 0x4e, 0x91, 0x0f, 0x10, 0xc2, 0x86,
	0x90, 0x92, 0x22, 0x95, 0x57, 0x51, 0x0f, 0x03, 0xd6, 0x7f, 0x0f, 0x38, 0x85, 0x59, 0x15, 0xc4,
	0x9f, 0xf8, 0xe8, 0x2e, 0xe7, 0x9f, 0x09, 0xa4, 0x0d, 0x97, 0x78, 0x06, 0x59, 0xac, 0x86, 0x93,
	0x32, 0x5e, 0xa3, 0xbc, 0xe6, 0x32, 0x1a, 0xc5, 0xb7, 0xf1, 0xa4, 0xbb, 0xc5, 0x8b, 0x7e, 0xfc,
	0x60, 0x6b, 0xc8, 0x21, 0xbf, 0x73, 0xf5, 0xab, 0x0f, 0x35, 0x71, 0x6f, 0x08, 0xfc, 0x98, 0x63,
	0xa1, 0x12, 0xb6, 0x56, 0x8d, 0x71, 0x3a, 0x44, 0x7a, 0x6b, 0x84, 0x7f, 0xde, 0x8c, 0x77, 0xe7,
	0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xea, 0x42, 0xdb, 0xa9, 0x01, 0x00, 0x00,
}
